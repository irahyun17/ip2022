# -*- coding: utf-8 -*-
"""Untitled18.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Cd3PGhZ97ONVWCyS7WT2csbjXZ-PG3RI
"""

def myfun(x, y):
  return x * y
myfun(3, 4)

def myfun(x):
  return x*3
def apply(q, x):
  return q(x)
apply(myfun, 7)

apply(lambda z: z * 4, 7)

def myfun(b, c=3, d="hello"):
  return b + c
myfun(5,3,"hello")
myfun(5,3)
myfun(5)

def myfun (a, b, c):
  return a-b
myfun(2, 1, 43)
myfun(c=43, b=1, a=2)
myfun(2, c=43, b=1)

class ai_student(student):

import somefile #Everything in somefile.py can be referred to by:
somefile.className.method("abc")
somefile.myFunction(34)

from somefile import * #Everything in somefile.py can be referred to by:
className.method("abc")
myFunction(34)

from somefile import className
className.method("abc") #<- This was imported
#myFunction(34) <- Not this one

"hello".upper()

x = "abc"
y = 34
"%s xyz %d" % (x, y)

print ("%s xyz %d" % ("abc", 34))

print ("abc")

print ("abc", "def")

";".join( ["abc", "def", "ghi"] )

"abc;def;ghi".split( ";" )

"Hello " + str(2)

class student:
  def __repr__(self):
    return "I’m named " + self.full_name

f = student("Bob Smith", 23)
print (f)
f

print (f.__doc__) #A class representing a student.
f.__class__ #< class studentClass at 010B4C6 >
g = f.__class__(“Tom Jones”, 34) #

fileptr = open("filename")
somestring = fileptr.read()
for line in fileptr:
  print (line)
fileptr.close()

def divide(x, y):
  try:
    result = x / y
  except ZeroDivisionError:
    print ("division by zero!")
  else:
    print ("result is", result)
  finally:
    print ("executing finally clause")

divide(2, 1)
divide(2, 0)
divide("2", "1")

for e in [1,2]:
  print (e)

s = [1,2]
it = iter(s)
it

it.next()
it.next()
it.next()

class Reverse:
  "Iterator for looping over a sequence backwards"
  def __init__(self, data):
    self.data = data
    self.index = len(data)
  def next(self):
    if self.index == 0:
      raise StopIteration
    self.index = self.index - 1
    return self.data[self.index]
  def __iter__(self):
    return self

for char in Reverse('spam'):
  print (char)

[x for x in Reverse('spam')]

[x + x for x in Reverse('spam')]

def reverse(data):
  for i in range(len(data)):
    yield data[len(data)-1-i]

for char in reverse('spam'):
  print (char)

def merge(l, r):
  llen, rlen, i, j = len(l), len(r), 0, 0
  while i < llen or j < rlen:
    if j == rlen or (i < llen and l[i] < r[j]):
      yield l[i]
      i += 1
    else:
      yield r[j]
      j += 1
g = merge([2,4], [1, 3, 5])
while True:
  print (g.next())

[x for x in merge([1,3,5],[2,4])]

g = merge([2,4], [1, 3, 5])
while True:
  try:
    print (g.next())
  except StopIteration:
    print ('Done')
    break

a = (x * x for x in xrange(5))
a

d = DiGraph([(1,2),(1,3),(2,4),(4,3),(4,1)])
print (d)

d = DiGraph([(1,2),(1,3),(2,4),(4,3),(4,1)])
[v for v in d.search(1)] #[1, 2, 4, 3]
[v for v in d.search(4)] #[4, 3, 1, 2]
[v for v in d.search(2)] #[2, 4, 3, 1]
[v for v in d.search(3)] #[3]

def __init__(self, edges):
  self.adj = {}
  for u,v in edges:
    if u not in self.adj: self.adj[u] = [v]
    else: self.adj[u].append(v)
def __str__(self):
  return '\n'.join(['%s -> %s'%(u,v) \
                    for u in self.adj for v in self.adj[u]])
  ...
  d = DiGraph([(1,2),(1,3),(2,4),(4,3),(4,1)])
  [v for v in d.search(1)]
  #{1: [2, 3], 2: [4], 4: [3, 1]}

def search(self, u, visited=set()):# If we haven't already visited this node...
  if u not in visited:# yield it
    yield u# and remember we've visited it now.
    visited.add(u)# Then, if there are any adjacant nodes...
    if u in self.adj:# for each adjacent node...
      for v in self.adj[u]:# search for all nodes reachable from *it*...
        for w in self.search(v, visited):# and yield each one.
          yield w